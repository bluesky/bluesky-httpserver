# Tests for user authorization and authentication on the working server
import pytest
import os
import pprint

from bluesky_queueserver.manager.tests.common import (  # noqa F401
    re_manager,
    re_manager_cmd,
)
from .conftest import fastapi_server_fs  # noqa: F401
from .conftest import request_to_json

from bluesky_httpserver.authorization._defaults import (
    _DEFAULT_ROLE_SINGLE_USER,
    _DEFAULT_SCOPES_SINGLE_USER,
    _DEFAULT_ROLE_PUBLIC,
    _DEFAULT_SCOPES_PUBLIC,
)


def _setup_server_with_config_file(*, config_file_str, tmpdir, monkeypatch):
    """
    Creates config file for the server in ``tmpdir/config/`` directory and
    sets up the respective environment variable. Sets ``tmpdir`` as a current directory.
    """
    config_fln = "config_httpserver.yml"
    config_dir = os.path.join(tmpdir, "config")
    config_path = os.path.join(config_dir, config_fln)
    os.makedirs(config_dir)
    with open(config_path, "wt") as f:
        f.writelines(config_file_str)

    monkeypatch.setenv("QSERVER_HTTP_SERVER_CONFIG", config_path)
    monkeypatch.chdir(tmpdir)

    return config_path


config_noauth_with_anonymous_access = """
authentication:
    allow_anonymous_access: True
"""

config_noauth_without_anonymous_access = """
authentication:
    allow_anonymous_access: False
"""

config_toy_with_anonymous_access = """
authentication:
    allow_anonymous_access: True
    providers:
        - provider: toy
          authenticator: bluesky_httpserver.authenticators:DictionaryAuthenticator
          args:
              users_to_passwords:
                  bob: bob_password
                  alice: alice_password
                  cara: cara_password
                  tom: tom_password
"""

config_toy_without_anonymous_access = """
authentication:
    allow_anonymous_access: False
    providers:
        - provider: toy
          authenticator: bluesky_httpserver.authenticators:DictionaryAuthenticator
          args:
              users_to_passwords:
                  bob: bob_password
                  alice: alice_password
                  cara: cara_password
                  tom: tom_password
"""

authorization_dict = """
api_access:
  policy: bluesky_httpserver.authorization:DictionaryAPIAccessControl
  args:
    users:
      bob:
        roles:
          - admin
          - expert
      alice:
        roles:
          - user
      cara:
        roles:
          - observer
"""

config_noauth_modify_default_roles = f"""
authentication:
  allow_anonymous_access: True
api_access:
  policy: bluesky_httpserver.authorization:DictionaryAPIAccessControl
  args:
    roles:
      {_DEFAULT_ROLE_SINGLE_USER}:
        scopes_add:
          - admin:apikeys
          - admin:read:principals
          - admin:metrics
        scopes_remove:
          - read:monitor
      {_DEFAULT_ROLE_PUBLIC}:
        scopes_set:
          - read:status
          - read:queue
          - read:history
"""


# fmt: on
@pytest.mark.parametrize(
    "cfg, access_cfg, single_user_access, public_access, token_access",
    [
        (config_toy_with_anonymous_access, authorization_dict, False, True, True),
        (config_toy_without_anonymous_access, authorization_dict, False, False, True),
        (config_toy_with_anonymous_access, "", False, True, False),
        (config_toy_without_anonymous_access, "", False, False, False),
        (config_noauth_with_anonymous_access, authorization_dict, True, True, False),
        (config_noauth_without_anonymous_access, authorization_dict, True, False, False),
        (config_noauth_with_anonymous_access, "", True, True, False),
        (config_noauth_without_anonymous_access, "", True, False, False),
        ("", authorization_dict, True, False, False),  # No authentication settings in config
        ("", "", True, False, False),  # No config file
    ],
)
# fmt: off
def test_authentication_and_authorization_01(
    tmpdir,
    monkeypatch,
    re_manager,  # noqa: F811
    fastapi_server_fs,  # noqa: F811
    cfg,
    access_cfg,
    single_user_access,  # Access in 'single-user' mode
    public_access,  # Public unauthenticated user works
    token_access,
):
    """
    Basic test: attempt to log into the server configured using various combinations of settings.

    Tested behavior:
        - Public unauthenticated access is disabled by default. Can be enabled by setting
          'allow_anonymous_access' True in the config file. (It can also be set using EV, but
          this option is not tested here.)
        - Single-user access is disabled if any authentication providers are listed in the config file.
        - Token is generated by logging in using valid username and password if the user is known
          to the authorization manager and the list of scopes is not empty. If the list of scopes
          is empty, then no token is generated (the user should not access the server).
        - Login with incorrect username or password does not work (token is not generated).
        - API can not be accessed using incorrect token or API key.
    """
    config = cfg + access_cfg
    providers_set = "providers" in config
    api_access_set = "api_access" in config

    if config:
        _setup_server_with_config_file(config_file_str=config, tmpdir=tmpdir, monkeypatch=monkeypatch)
    fastapi_server_fs()

    # Test if anonymous 'public' access works
    resp1 = request_to_json("get", "/status", api_key=None)
    if public_access:
        assert "msg" in resp1, pprint.pformat(resp1)
        assert "RE Manager" in resp1["msg"]
    else:
        assert "detail" in resp1, pprint.pformat(resp1)
        assert "Not enough permissions" in resp1["detail"]

    # Make sure that the anonymous 'single-user' access is not allowed
    resp2 = request_to_json("get", "/status")  # By default, the single user API key is sent
    if single_user_access:
        assert "msg" in resp2, pprint.pformat(resp1)
        assert "RE Manager" in resp2["msg"]
    else:
        assert "detail" in resp2, pprint.pformat(resp2)
        assert "Invalid API key" in resp2["detail"]

    if api_access_set:
        login_fail_msg = "Incorrect username or password"
    else:
        login_fail_msg = "User is not authorized to access the server"
    login_fail_msg = login_fail_msg if providers_set else "Not Found"

    # auth_fail_msg1 = "Incorrect username or password" if providers_set else "Not Found"
    auth_fail_msg = "Incorrect username or password" if providers_set else "Not Found"

    # Login using token: should work in all cases
    resp3 = request_to_json("post", "/auth/provider/toy/token", login=("bob", "bob_password"))
    if token_access:
        assert "access_token" in resp3
        token = resp3["access_token"]
        resp4 = request_to_json("get", "/status", token=token)
        assert "msg" in resp4, pprint.pformat(resp4)
        assert "RE Manager" in resp4["msg"]
    else:
        assert "detail" in resp3
        assert login_fail_msg in resp3["detail"]

    # Login using incorrect username
    resp5 = request_to_json("post", "/auth/provider/toy/token", login=("incorrect_name", "bob_password"))
    assert "detail" in resp5
    assert auth_fail_msg in resp5["detail"]

    # Login using invalid password
    resp6 = request_to_json("post", "/auth/provider/toy/token", login=("bob", "invalid_password"))
    assert "detail" in resp6
    assert auth_fail_msg in resp6["detail"]

    # Try using invalid token
    resp7 = request_to_json("get", "/status", token="INVALIDTOKEN")
    assert "detail" in resp7, pprint.pformat(resp7)
    assert "Could not validate credentials" in resp7["detail"]


def test_authentication_and_authorization_02(
    tmpdir,
    monkeypatch,
    re_manager,  # noqa: F811
    fastapi_server_fs,  # noqa: F811
):
    """
    Check default scopes for 'single-user' and public access. No authentication providers
    or authorization policy are defined in the config file.
    """

    config = config_noauth_with_anonymous_access
    _setup_server_with_config_file(config_file_str=config, tmpdir=tmpdir, monkeypatch=monkeypatch)
    fastapi_server_fs()

    # Check that both single-user access and public access work
    #   (by default 'api_key' is set to valid single-user API key)
    for params in ({}, {"api_key": None}):
        print(f"Test case: params={params}")

        resp1 = request_to_json("get", "/status", **params)
        assert "msg" in resp1, pprint.pformat(resp1)
        assert "RE Manager" in resp1["msg"]

        if not params:
            roles = [_DEFAULT_ROLE_SINGLE_USER]
            scopes = set(_DEFAULT_SCOPES_SINGLE_USER)
        else:
            roles = [_DEFAULT_ROLE_PUBLIC]
            scopes = set(_DEFAULT_SCOPES_PUBLIC)

        resp2a = request_to_json("get", "/auth/scopes", **params)
        assert "roles" in resp2a, pprint.pformat(resp2a)
        assert "scopes" in resp2a, pprint.pformat(resp2a)
        assert resp2a["roles"] == roles
        assert set(resp2a["scopes"]) == scopes


def test_authentication_and_authorization_03(
    tmpdir,
    monkeypatch,
    re_manager,  # noqa: F811
    fastapi_server_fs,  # noqa: F811
):
    """
    Check default scopes for 'single-user' and public access. No authentication providers
    or authorization policy are defined in the config file.
    """

    config = config_noauth_modify_default_roles
    print(f"=========== config = {config!r}")
    _setup_server_with_config_file(config_file_str=config, tmpdir=tmpdir, monkeypatch=monkeypatch)
    fastapi_server_fs()

    # Check that both single-user access and public access work
    #   (by default 'api_key' is set to valid single-user API key)
    for params in ({}, {"api_key": None}):
        print(f"Test case: params={params}")

        resp1 = request_to_json("get", "/status", **params)
        assert "msg" in resp1, pprint.pformat(resp1)
        assert "RE Manager" in resp1["msg"]

        if not params:
            roles = [_DEFAULT_ROLE_SINGLE_USER]
            scopes_to_add = {"admin:apikeys", "admin:read:principals", "admin:metrics"}
            scopes_to_remove = set(["read:monitor"])
            scopes = (set(_DEFAULT_SCOPES_SINGLE_USER) | scopes_to_add) - scopes_to_remove
        else:
            roles = [_DEFAULT_ROLE_PUBLIC]
            scopes = {"read:status", "read:queue", "read:history"}

        resp2a = request_to_json("get", "/auth/scopes", **params)
        assert "roles" in resp2a, pprint.pformat(resp2a)
        assert "scopes" in resp2a, pprint.pformat(resp2a)
        assert resp2a["roles"] == roles
        assert set(resp2a["scopes"]) == set(scopes)
